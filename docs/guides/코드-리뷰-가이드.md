# 코드 리뷰 가이드

## 코드 리뷰의 목적

1. **코드 품질 향상**: 버그 발견, 더 나은 해결책 제시
2. **지식 공유**: 서로 배우고 성장하기
3. **일관성 유지**: 코딩 스타일, 패턴 통일
4. **멘토링**: 경험 공유 및 학습 지원

## 리뷰어 역할 분담

### Frontend 3년차
- 1년차 개발자 PR 우선 리뷰
- 디자이너 PR 필수 리뷰
- 아키텍처, 성능 관련 피드백

### Frontend 1년차
- 서로의 PR 리뷰
- 디자이너 PR 리뷰 (간단한 것들)
- 같이 배우는 관점에서 질문하기

### 디자이너
- 다른 멤버 PR 보면서 학습
- 궁금한 점 질문하기
- UI/UX 관점에서 피드백

## 리뷰 체크리스트

### 기본 사항
- [ ] 코드가 정상적으로 실행되는가?
- [ ] PR 설명이 명확한가?
- [ ] 커밋 메시지가 규칙을 따르는가?

### 코드 품질
- [ ] 코드가 읽기 쉬운가?
- [ ] 불필요한 중복이 없는가?
- [ ] 변수/함수 이름이 명확한가?
- [ ] 불필요한 console.log가 제거되었는가?

### React Native 특화
- [ ] 컴포넌트가 적절히 분리되어 있는가?
- [ ] StyleSheet를 사용하는가?
- [ ] 성능을 고려했는가? (FlatList, memo 등)
- [ ] 플랫폼별 차이를 고려했는가?

### TypeScript
- [ ] 타입이 명확히 정의되어 있는가?
- [ ] any 타입을 남용하지 않았는가?
- [ ] 타입 에러가 없는가?

## 리뷰 코멘트 작성법

### ✅ 좋은 예

**구체적인 피드백**
```
이 부분에서 FlatList를 사용하면 성능이 더 좋을 것 같아요.
ScrollView는 모든 아이템을 한번에 렌더링하지만,
FlatList는 보이는 부분만 렌더링해서 메모리 효율적입니다.

예시:
<FlatList
  data={items}
  renderItem={({item}) => <Item {...item} />}
  keyExtractor={item => item.id}
/>
```

**질문 형식**
```
이 로직을 useState 대신 useReducer로 관리하면 어떨까요?
상태 업데이트가 복잡해 보여서요. 어떻게 생각하시나요?
```

**칭찬과 함께**
```
Navigation 구조를 깔끔하게 잘 정리하셨네요! 👍
여기에 TypeScript 타입까지 추가하면 더 완벽할 것 같아요.
```

### ❌ 피해야 할 예

**모호한 피드백**
```
이 코드는 좋지 않은 것 같아요.
```

**공격적인 표현**
```
이렇게 하면 안되죠. 왜 이렇게 했어요?
```

**단순한 지적만**
```
틀렸어요.
```

## 리뷰 받는 사람을 위한 팁

### PR 작성 시
1. **명확한 설명**: 무엇을, 왜 했는지
2. **스크린샷 첨부**: 시각적 변경사항
3. **고민한 점 공유**: 피드백 받고 싶은 부분 명시
4. **자체 리뷰**: 올리기 전에 한번 더 확인

### 피드백 받을 때
1. **열린 마음**: 배우는 기회로 생각하기
2. **질문하기**: 이해 안 되면 물어보기
3. **방어적이지 않기**: "왜 이렇게 했어요?"는 공격이 아니라 궁금증
4. **감사 표현**: 시간 내서 리뷰해준 것에 감사

## 코멘트 종류

### 🔴 필수 수정 (MUST)
```
[필수] 이 부분은 보안 이슈가 있어서 꼭 수정이 필요합니다.
API 키가 코드에 노출되어 있네요.
```

### 🟡 권장 (SUGGEST)
```
[권장] 이 로직을 커스텀 훅으로 분리하면 재사용하기 좋을 것 같아요.
```

### 🟢 의견 (OPINION)
```
[의견] 제 생각엔 이렇게 하면 더 읽기 쉬울 것 같은데, 어떻게 생각하세요?
```

### 💬 질문 (QUESTION)
```
[질문] 이 부분에서 useCallback을 사용한 이유가 궁금해요!
```

### 👍 칭찬 (PRAISE)
```
[칭찬] 에러 처리를 꼼꼼하게 하셨네요! 👏
```

## 리뷰 프로세스

### 1. PR 생성 시
- 리뷰어 지정 (최소 1명)
- Labels 추가
- 설명 작성

### 2. 리뷰 요청 받으면
- **24시간 내** 응답 목표
- 바쁘면 "주말에 리뷰할게요!" 코멘트

### 3. 리뷰 진행
- 코드 꼼꼼히 읽기
- 이해 안 되는 부분 질문
- 개선점 제안
- 좋은 부분 칭찬

### 4. 수정 요청 시
- 구체적인 가이드 제시
- 예시 코드 첨부

### 5. 재리뷰
- 수정 사항 확인
- Approve 또는 추가 코멘트

### 6. 머지
- 모든 리뷰어 승인 시
- CI/CD 체크 통과 시
- Squash and merge 권장

## 리뷰 시간 분배

### 간단한 PR (5-10분)
- 문서 수정
- 작은 버그 픽스
- 스타일 변경

### 중간 PR (15-30분)
- 새 컴포넌트 추가
- 기능 구현
- 리팩토링

### 복잡한 PR (30분-1시간)
- 아키텍처 변경
- 대규모 기능
- 여러 파일 수정

## 리뷰 예시

### 디자이너의 첫 PR 리뷰

```markdown
### 전체적인 인상
첫 PR인데 정말 잘하셨어요! 👏
기본 컴포넌트 사용법을 정확히 이해하신 것 같아요.

### Button.tsx
[칭찬] StyleSheet로 스타일을 분리한 점 좋습니다!

[질문] `onPress` props의 타입을 정의하면 더 안전할 것 같아요.
```typescript
interface ButtonProps {
  title: string;
  onPress: () => void;
}
```
이렇게 하면 잘못된 props를 전달했을 때 에러로 알려줍니다.

### styles
[권장] 색상 값을 상수로 분리하면 나중에 테마 변경이 쉬워요.
```typescript
const COLORS = {
  primary: '#007AFF',
  white: '#FFFFFF',
};
```

### 종합
구조는 완벽합니다! TypeScript 타입만 추가하면 머지해도 될 것 같아요.
궁금한 점 있으면 언제든 물어보세요! 😊
```

### 1년차 개발자의 PR 리뷰

```markdown
### Navigation 구조
[칭찬] Stack과 Tab Navigation을 잘 조합하셨네요!

### screens/HomeScreen.tsx
[권장] 이 로직은 커스텀 훅으로 분리하면 재사용하기 좋을 것 같아요.

**Before:**
```typescript
const [data, setData] = useState([]);
const [loading, setLoading] = useState(false);

useEffect(() => {
  setLoading(true);
  fetchData().then(setData).finally(() => setLoading(false));
}, []);
```

**After:**
```typescript
// hooks/useFetchData.ts
const useFetchData = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    setLoading(true);
    fetchData().then(setData).finally(() => setLoading(false));
  }, []);

  return { data, loading };
};

// screens/HomeScreen.tsx
const { data, loading } = useFetchData();
```

### types/index.ts
[필수] User 타입에 id가 빠져있는 것 같아요.
나중에 FlatList에서 keyExtractor 사용할 때 필요합니다.

전반적으로 잘 구현하셨습니다! 위 사항만 수정하면 LGTM! 🚀
```

## 자주 발생하는 이슈

### Performance
```typescript
// ❌ 매번 새 함수 생성
<Button onPress={() => handlePress(item.id)} />

// ✅ useCallback 사용
const handlePress = useCallback((id) => {
  // ...
}, []);
```

### Type Safety
```typescript
// ❌ any 사용
const handleData = (data: any) => { }

// ✅ 명확한 타입
interface Data {
  id: string;
  name: string;
}
const handleData = (data: Data) => { }
```

### Style
```typescript
// ❌ Inline style
<View style={{ flex: 1, padding: 20 }} />

// ✅ StyleSheet
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
});
```

## 참고 자료

- [Google의 코드 리뷰 가이드](https://google.github.io/eng-practices/review/)
- [React Native Best Practices](https://reactnative.dev/docs/performance)
- [Conventional Comments](https://conventionalcomments.org/)

## 마무리

코드 리뷰는 서로 배우고 성장하는 과정입니다.
완벽한 코드는 없으니 부담 갖지 말고,
서로 도우면서 함께 발전해나가요! 💪
